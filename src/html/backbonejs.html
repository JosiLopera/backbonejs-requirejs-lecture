<!-- ********************* BACKBONE PRESENTATION 01/03 ********************** -->
<section>
	<h1>Tutoriel Backbonejs</h1>
	<img class="logo" src="http://arcane-refuge-8744.herokuapp.com/img/backbone-300x300.png">
	<p>
		<small>Created by <a href="#">Antonio Pierro</a> / <a href="http://twitter.com/antonio_pierro_">@antonio_pierro_</a></small>
	</p>
</section>
<!--SLIDE1-->
<section>
	<section>
	<h2>What Is MVC?</h2>
		<ul>
			<li>MVC is a software architecture which consists of separation of model, view and controller.</li>
			<li>The model could be a database, or any number of data structures or storage systems.</li>
			<li>The view provides the user interface element of the application.</li>
			<li>The controller receives user input and makes calls to model objects and the view to perform appropriate actions.
			<li>This paradigm suggests to avoid mixing code from the three categories into one class.</li>
			</li>
		</ul>
		<aside class="notes"><h2>Qu'est-ce que MVC?</h2>
		<ul>
			<li>MVC de l'anglais model-view-controller</li>
			<li>Ce paradigme regroupe les fonctions nécessaires en trois catégories :</li>
			<ol>
				<li>un modèle (modèle de données)</li>
				<li>une vue (présentation, interface utilisateur)</li>
				<li>un contrôleur (logique de contrôle, gestion des événements, synchronisation)</li>
			</ol>
		</ul></aside>
	</section>
	<section>
		<h2>"Bonjour tout le monde" en modèle MVC</h2>
		<pre><code>var M = {}, V = {}, C = {};

M.data = "Bonjour tout le monde";

V.render = function (M) { alert(M.data); }

C.handleOnload = function () { V.render(M); }

window.onload = C.handleOnLoad;</code></pre>
	</section>

	<section><h2>What does MVC give us?</h2>
<ul>
	<li>Easier overall maintenance. When updates need to be made to the application it is clear whether the changes are data-centric or merely visual, meaning changes to views.</li>
	<li>This modularity allows developers responsible for core logic and developers working on the user-interfaces to work simultaneously</li>
</ul>
	</section>

</section>

<section>
	<section>
		<h2>What is Backbonejs?</h2>
		<ul>
			<li><em>BackboneJS</em> is a Model-View-Controller (MVC) framework for client-facing JavaScript.</li>
			<li>Backbone aims to solve the code coupling problem by providing a model-view framework with templates that separate programming concerns</li>
			<li>It isn’t possible to talk about Backbone without also discussing Underscore.js, Backbone’s prerequisite helper library.</li>
		</ul>
	</section>
	<section>
		<h2>"Bonjour tout le monde" en modèle Backbone.js</h2>
		<pre><code>(function($){
     var AppView = Backbone.View.extend({    
         el: $('body'),
         render: function(){
             $(this.el).append("Bonjour tout le monde");
         },
         initialize: function(){
             _.bindAll(this, 'render');           
             this.render();
         },
     });
     var appView = new AppView();      
 })(jQuery);</code></pre>
	</section>
</section>

<section>

<section><h2>When Do I Need BackboneJS?</h2>
<ul>
	<li>When building a single-page application using JavaScript 
	and you want to reduce the number of HTTP requests required for new Views.</li>
	<li>If you're writing an application where most of the view rendering and data manipulation occurs in the browser. (Examples: GMail and Google Drive)</li>
</ul>

<aside class="notes"><h2>Quand utiliser Backbone.js</h2>
	<ul>
		<li>Backbonejs est un excellent choix pour les applications dites «single page application», c’est à dire une page principale avec un nombre important d’interactions utilisateur.</li>
		<li>Le code créé avec Backbone.js peut être testé via jasmine.</li>
	</ul>
	<ul>
	<li><em>gmail - google drive</em> These types of applications typically download a single payload containing all the scripts, 
	stylesheets and markup users need for common tasks and then perform a lot of additional behavior in the background. 
	For instance, 
	it's trivial to switch between reading an email or document to writing one and a new page is never requested from the server.</li>
</ul></aside>

</section>

<section><h2>Backbone’s main benefits</h2>
<ul>
	<li>Organize the structure to your application</li>
	<li>Simplify server-side persistence</li>
	<li>Decouple the DOM from your page’s data</li>
	<li>Model data, views and routers in a succinct manner</li>
	<li>Provide DOM, model and collection synchronization</li>
</ul>
<aside class="notes"><ul>
	<li>Dans l'illustration suivante, le résultat n'est pas prévisible, du fait que vous ne pouvez savoir quand les Thread A et B s'exécutent. Dans l'hypothèse la plus simple ou les thread A et B s'exécutent une fois, l'ordre d'exécution des instructions peut être par exemple : Lire, Lire, Add, Add, Écrire, Écrire ou Lire, Add, Écrire, Lire, Add, Écrire. Le résultat dans ces deux hypothèses n'est pas le même puisqu'au final dans le second cas la variable est augmentée de 2 alors qu'elle n'est augmentée que de un dans le premier.</li>
</ul></aside>
</section>

</section>

<!-- **************** THE BACKBONE MODEL ******************** !-->
<section>
	<section><h2>Backbone Model</h2>
	<ul>
		<li>Backbone model contains data as key/value pair
<pre><code>{
    "title": "my title", 
    "completed": true
}
</code></pre>
		</li>
		<li>Backbone model contains the logic around this data: 
		conversions, validations, computed properties, and access control.
<pre><code>task.set({completed: false});
task.get('completed'); // false</code></pre>
</li>

	</ul>
	<aside class="notes">
		<h2>Définition du modèle</h2>
		<ul>
			<li>Contient les données d’un objet – associations clés/valeurs.</li>
			<li>Les modèles sont responsables de la logique métier (business logic) et peuvent également servir pour la persistance, aussi bien locale avec localStorage que distante via des API RESTful en JSON.</li>
			<li>Les modèles proposent des enregistrements clé‐valeur et des événements associés.</li>
		</ul>

	        A common misconception is that the DOM is a part of the JavaScript language. It isn’t. In fact, it is a completely separate API that JavaScript interacts with. Having the ability to query the current “state” of your application without always resorting to querying the DOM is a HUGE WIN.
	        </aside>
	</section>
	<section>
		<h2>Backbone Model: creation</h2>
		<ul>
			<li>Models can be created by extending Backbone.Model as follows:
		<pre><code>var MyModel = Backbone.Model.extend({});</code></pre>
		</li>
			<li> We can then create our own concrete instance of a (MyModel) model with no values at all:
				<pre><code>var myModel1 = new MyModel();
console.log(myModel1);
// or with some arbitrary data:
var myModel1 = new MyModel({
     title: 'my first title model', 
     completed: true
});</code></pre>
			</li>
		</ul>
		<aside class="notes">extend sets up the prototype chain</aside>
	</section>
	<section>
		<h2>Backbone Model: creation: Initialization</h2>
		<ul>
			<li>The initialize() method is called when a new instance of a model is created. Its use is optional, however you’ll see why it’s good practice to use it below:
			<pre><code>var MyModel = Backbone.Model.extend({ 
	initialize: function(){
         console.log('This model has been initialized.'); 
     }
});
var myModel = new MyModel();</code></pre></li>
		</ul>
	</section>
	<section>
		<h2>Backbone Model: Default values</h2>
		<ul>
		<li>
			There are times when you want your model to have a set of default values (e.g. in a scenario where a complete set of data isn’t provided by the user):
			<pre><code>var MyModel = Backbone.Model.extend({
     defaults: {
         'title': '',
         'completed': false
     }
});</code></pre>
		</li>
		</ul>
	</section>
	<section>
		<h2>Backbone Model: Getters & Setters</h2>
		<ul><li>Model.get() provides easy access to a model’s attributes.
		<pre><code>myModel.get('title');
myModel.toJSON() // get all of a model’s data attributes </code></pre>
		</li>
		<li>Model.set() allows us to pass attributes into an instance of our model:
		<pre><code>myModel.set("title", "My new title."); 
console.log('myModel title: ' + myModel.get('title'));</code></pre></li></ul></section>
		<section><h2>Backbone Model: Listening for changes to your model</h2>
		<ul><li>Modèle can have listeners bound to them which detect when their values change:
		<pre><code>var MyModel = Backbone.Model.extend({
     initialize: function() {
         this.on('change', function() {
             console.log('- Values for this model have changed.');
         });
     }
});</code></pre> </li></ul>
	</section>

	<section>
		<h2>Backbone Model: Validation</h2><ul><li>
		Backbone supports model validation which allows checking the attribute values for a model prior to them being set.<pre><code>var MyModel = Backbone.Model.extend({  
     validate: function(attribs, options) {
         if(attribs.title === undefined) {
             return "Remember to set a title for your todo.";
         } 
     }
});</code></pre>
		 <aside class="notes">
		 <ul>
		 	<li>By default validate is called before save, but can also be called before set if {validate:true} is passed.</li>
		 	<li>Backbone passes the attributes object (attribs param in above example) by shallow copy to the validate function using the Underscore _.extend method. This means that it is not possible to change any Number, String or Boolean attribute but it is possible to change attributes of objects because they are passed by reference. As shallow copy doesn’t copy objects by implicitly copying them, but rather, by reference, one can change the attributes on those objects.
		An example of this (by @fivetanley) is available <a target="_" href="http://jsfiddle.net/2NdDY/7/">here</a>.
		 	</li>
		 </ul> </aside>
		</li></ul>
	</section>
	<section><h2>Modèle en détail: Exercice</h2></section>
	<section><h2>Modèle en détail: Solution</h2></section>
</section>

<!-- **************** THE BACKBONE VIEW ******************** !-->
<section>
	<section>
		<h2>Backbone View</h2>
		<ul>
			<li>Views represent a display of data within a model, usually providing different information depending upon the context needed.</li>
			<li>Views in Backbone don’t contain the markup for your application, but rather they are there to support models by defining the logic for how they should be represented to the user. (This is usually achieved using JavaScript templating (e.g. Mustache, jQuery-tmpl, etc.).)</li>
		</ul>
		<aside class="notes"><ul>
		<li>Les vues font la liaison entre les modèles et le DOM. </li>
		<li>Elles mettent à jour le code HTML en fonction des modifications des modèles et, dans l’autre sens, peuvent gérer les événements du DOM;</li>
		</ul></aside>
	</section>

<section>
	<h2>Creating new views</h2>
	<ul>
		<li>To create a new View, simply extend Backbone.View</li>
		<pre><code>var MyView = Backbone.View.extend({});

var myView = new MyView();

console.log(myView.el);</code></pre>
	<li>What is el? el is basically a reference to a DOM element and all views must have one. </li>
	</ul>
	<aside class="notes">	<h2>Vue en détail: création</h2>
	<ul><li>Les Vues peuvent être créés par:<pre><code>var MyView = Backbone.View.extend({
});
var myView = new MyView();
console.log(myView.el);
	</code></pre></li>
	<li><strong>el</strong> is basically a reference to a DOM element and all views must have one.</li></ul></aside>
</section>

<section>
<h2>Backbone View: tagName, id and className</h2>
<ul><li>If you want to create a new element for your view,<br>set any combination of the following view’s properties: <br>tagName, id and className<pre>
<code>var MyView = Backbone.View.extend({
     tagName: 'ul', // required, but defaults to 'div' if not set
     className: 'container', // optional
     id: 'todos' // optional
});
var myView = new MyView();
console.log(myView.el);
</code>
</pre></li>
</section>

<section>
	<h2>Backbone View: template</h2>
	<ul>
		<li>
			It's convenient to define a template file to use on your view:s
<pre><code>//template file
<script type="text/template" id="form-tpl">
    <label>Name:</label>
    <input type="text" name="name" value="<%= name %>">
    <label>Age:</label>
    <input type="text" name="age" value="<%= age %>">
</script>
<div id="form"></div>
</code></pre>
<pre><code>var MyView = Backbone.View.extend({
     el: "#form",
     render: function() {
         var html = _.template($('#form-tpl').html(), {age:12, name:'ciao'});
         this.$el.html(html);
    }
});</code></pre>
</li>
<li>You can pass the model to the istance view:<pre><code>myView = new MyView({model: myModel});</code></pre></li>
	</ul>
</section>

<section><h2>Backbone View: Exercice 1</h2>
<ul>
	<li>Create a web page that can be run directly in a web browser. <ul>
		<li>Before any coding can begin, the jQuery, Underscore, and Backbone libraries are included within the page’s head;</li>
	</ul></li>
	
	<li>Create a CertificateView class, which is a placeholder for a birth certificate (uses Backbone’s extend method to create a prototype chain)</li>
	<ul>
		<li>The view will have two custom functions: 
		<ul>
		<li><em>initialize</em>: Executed when a new instance of the view is created; in this case, the desire is for the view to render its contents immediately</li>
		<li><em>render</em>: Draws the contents of the view to the target element as described next. You specifically instruct the view to render itself inside the div whose ID is certificate</li>
		</ul>
		</li>
	</ul>
</ul>

	</section>
<section><h2>Backbone View: Solution 1</h2>
<pre><code><div id="certificate"></div>
<script type="text/javascript"> 
CertificateView = Backbone.View.extend({
    initialize: function() { 
    	this.render();
    },
    render: function() {
        $(this.el).html("<h1>Guy Incognito</h1><p>DOB: March 2, 1967</p>");
    } });
    var certificate_view = new CertificateView({ el: $("#certificate")}); 
</script></code></pre>
</section>



<section><h2>Backbone View: Exercice 2</h2>
<ul><li>Create a model and a view class.</li>
<li>Create an instance of model and view</li>
<li>Create a template</li>
<li>Use all together to create an app able to render the model in the view</li></ul></section>

<section><h2>Backbone View: <a target="_" href="http://jsfiddle.net/CX3ud/29/">Solution 2</a></h2>
<pre><code><script type="text/template" id="form-tpl">
    <label>Name:</label>
    <input type="text" name="name" value="<%= name %>">
    <label>Age:</label>
    <input type="text" name="age" value="<%= age %>">
</script>
<div id="form"></div></code></pre>
<pre><code>var MyModel = Backbone.Model.extend({});
var MyView = Backbone.View.extend({
    el: "#form",
    render: function() {
        var html = _.template($('#form-tpl').html(), this.model.toJSON());
        this.$el.html(html);
    }
});

$(function() {
    var person = new MyModel({
        name: 'Thomas',
        age: 37
    }),
    app = new MyView({model: person});
    app.render();
});</code></pre>
</section>



</section>

<!-- 
****************************************************************************
**************** THE BACKBONE COLLECTION ***************************************
****************************************************************************
 !-->
<section>
<section>
<h2>Backbone collection</h2>
<ul>
<li>Collections are ordered sets of models.</li>
<li>When creating a collection you need to pass through a property specifying the model that your collection will contain.</li>
<li>A collection can also contain polymorphic models by overriding this property with a constructor that returns a model.</li>
</ul>

<aside class="notes"><ul><li>Les collections offrent un catalogue bien pratique de méthodes d’énumération: ce sont les méthodes map, reduce, filter importées depuis underscore.js</li>
<li>underscore.js est une des rares dépendances de Backbone.js</li>
</ul>

	<aside class="notes">
<pre><code>var Library = Backbone.Collection.extend({

  model: function(attrs, options) {
    if (condition) {
      return new PublicDocument(attrs, options);
    } else {
      return new PrivateDocument(attrs, options);
    }
  }

});</code></pre>
	</aside>
</aside>
</section>

<section>
<h2>Backbone collection: creation</h2>
<ul>
	<li>In the following example, we create a TaskCollection that will contain our Task model:
		<pre><code>var TaskCollection = Backbone.Collection.extend({
			model: myModel
});

var taskCollection = new TaskCollection();

console.log(taskCollection);
</code></pre>
	</li>
</ul>
	
	<aside class="notes"><h2>Backbone collection: création</h2>
	<ul><li>On suppose d'avoir déjà défini un modèle MyModel</li>
		<li>la collection peut être créés par:<pre><code>var MyCollection = Backbone.Collection.extend({
			model: myModel
});
var myCollection = new MyCollection();
console.log(myCollection);
</code></pre></li>
	</ul></aside>
</section>

<section><h2>Backbone collection: Getters and Setters</h2>
<ul>
<li>Collection.get() accepts a single id as follows:<pre><code>var myModel2 = myCollection.get(2);</code></pre></li>
<li>Backbone Collections don’t have setters as such, <br>
	but do support adding new models via <strong>.add()</strong><br>
	and removing models via <strong>.remove()</strong>.</li>
</ul>
</section>

<section><h2>Backbone collection: reset</h2>
<ul>
<li>Rather than adding or removing models individually, <br>
	you might occasionally wish to update an entire collection at once:
	<pre><code>myCollection.add([
     { title: 'go to Jamaica.', completed: false }, 
     { title: 'go to China.', completed: false },
     { title: 'go to Disneyland.', completed: true }
]);
console.log('Collection size: ' + myCollection.length);
myCollection.reset([
     { title: 'go to Cuba.', completed: false }
]);
console.log('Collection size: ' + myCollection.length);</code></pre></li>
<li>Calling collection.reset() without passing any models as arguments will empty the entire collection</li>
</ul>
</section>

<section><h2>Backbone collection: forEach et sortBy()</h2>
<ul>
<li><strong>forEach</strong> method can be used for iterating over collection:<pre><code>TodosCollection.forEach(function(model){ 
	console.log(model.get('title'));
});
</code></pre></li>
<li><strong>sortBy()</strong> method that can be used to sort a collection of todos based on a particular attribute:<pre><code>var sortedByAlphabet = TodosCollection.sortBy(function (todo) {
     return todo.get("title").toLowerCase();
});</code></pre></li>
</ul>
</section>

<section><h2>Collection en détail: xxxxxxxx</h2>
<ul>
<li></li>
<li></li>
</ul>
</section>

</section>

<!-- 
****************************************************************************
**************** THE BACKBONE ROUTER ***************************************
****************************************************************************
 !-->
<section>
<section>
	<h2>Router</h2>
	<ul>
		<li>Routers are used to help manage application state and for connecting URLs to application events.</li>
		<li>Note the inline comments in the code example below as they continue the the lesson on routers.
		<pre><code>var MyRouter = Backbone.Router.extend({
    routes: { 
        "about" : "showAbout",
        /* Sample usage: http://example.com/#about */,

        "todo/:id" : "getTodo",
        /* This is an example of using a ":param" variable
         which allows us to match any of the components 
         between two URL slashes */
        /* Sample usage: http://example.com/#todo/5 */

        "*other" : "defaultRoute"
        /* This is a default route */
        /* Sample usage: http://example.com/#"anything" */

        showAbout: function(){ ... } ,
        ...
    }
});
		</code></pre></li>
	</ul>
</section>
<section><h2>Is there a limit to the number of routers I should be using?</h2>
<ul>
	<li>Usually you should use a single router in most of their applications.</li>
	<li>You’re very likely to not require more than one or two routers in your own projects; the majority of your application routing can be kept organized in a single router without it getting unwieldy.</li>
</ul></section>
</section>
</section>




<!--

<section>
<section>
	<h2>L’architecture du projet</h2>
	<p> Notre application devrait être découplée en plusieurs fichiers, en séparant modèle, vue etc…</p>
		<a href="#" class="image navigate-down">
			<img width="108" height="138" src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png" alt="Down arrow">
		</a>
</section>
<section>
		<ul>
			<li>assets</li>
			<ul>
				<li>js</li>
			</ul>
			<li>src</li>
			<li>modules</li>
		</ul>
</section>
<section>
	<ul>
		<li><b>assets/</b>: répertoire regroupant la plupart des fichiers statiques, comme les fichiers CSS, les images ainsi que les srclibrairies JavaScripts (backbone.js, jquery.js et underscore.js)</li>
		<li><b>src/</b>: c’est le dossier de notre application Backbone.js, il va contenir tous les fichiers JavaScript propres à notre application. Le dossier modules/ regoupera les vues, le router, les collections et les models. </li>
	</ul>	
</section>
	<aside class="notes">
		Oh hey, these are some notes. They'll be hidden in your presentation, but you can see them if you open the speaker notes window (hit 's' on your keyboard).
	</aside>

</section>

-->
<section>
	<section><h2>Exercise 1: task management app</h2><h3>Your First Backbone.js App</h3>
<ul>
	<li>Let's consider the application's architecture at a high level. We'll need:
	<ul>
		<li>a Task model to describe individual task items</li>
		<li>a TaskList collection to store and persist tasks</li>
		<li>a way of creating tasks</li>
		<li>a way to display a listing of tasks</li>
		<li>a way to edit existing tasks</li>
		<li>a way to deem a task complete</li>
		<li>a way to delete tasks</li>
		<li>a way to bookmark the tasks that have been completed or are remaining</li>
	</ul>
	</li>
</ul>
<aside class="notes">Now that we’ve covered fundamentals, let’s write our first Backbone.js application.</aside>
	</section>

<section><h2>Index</h2><ul>
	<li>First, we'll set up the basic application dependencies: jQuery, Underscore, Backbone.js and the Backbone LocalStorage adapter.</li>
	</ul>
	<aside class="notes">
Comme vous le pouvez le voir, le contenu html de notre application sera englobé dans une div avec l’id «content », c’est surtout pour éviter d’écraser l’insertion des librairies ou autres codes importants comme les templates. C’est donc le sélecteur $(‘#content’) que l’on utilisera pour initier la base de notre application. Ensuite on inclut toutes les librairies dont Backbone JS a besoin pour fonctionner, là rien de bien méchant, attention cependant, jQuery et underscore.js doivent être inclus avant backbone.js.
	</aside>
</section>

<section><h2>Application HTML</h2>
<ul>
	<li>Now let's take a look at our application's static HTML. We'll need an:</li>
	<ul>
		<li><u>&lt;input&gt;</u> for creating new tasks</li>
		<li><u>&lt;ul id="todo-list"&gt;</u> for listing the actual tasks and a section containing some operations, such as clearing completed tasks.</li>
	</ul>
</ul></section>

<section><h2>Todo model</h2>
	
</section>

</section>
				<!--SLIDE_3-->


<!--END SLIDE_3-->
<section>
	<h3>References</h3>
	<p>
		<ul>
			<li><a href="https://github.com/ccoenraets/directory-backbone-bootstrap">Sample Application built with Backbone.js and Twitter Bootstrap</a></li>
			<li><a href="http://www.teaching-materials.org/backbone/">GETTING STARTED WITH BACKBONE</a></li>
			<li><a target="_" href="http://linuxfr.org/news/d%C3%A9couvrez-backbonejs%C2%A0050-pour-organiser-votre-code-javascript">Découvrez Backbone.js 0.5.0 pour organiser votre code JavaScript</a></li>
			<li><a target="_" href="http://www.atinux.fr/2011/12/10/organiser-son-code-backbone-js-en-modules/">Organiser son code Backbone JS en modules</a></li>
			<li><a target="_" href="http://blog.keiruaprod.fr/2012/05/08/intro-a-backbone-js-1-les-vues/">Intro à Backbone.js – #1 : les vues</a></li>
			<li><a target="_" href="http://fr.clever-age.com/veille/blog/decouvrir-backbone-js-avec-todomvc.html">Découvrir Backbone.js au travers de l’application TodoMVC</a></li>
			<li><a target="_" href="http://www.rvl.io/mindelusions/backbonejs">backbonejs on reveal.js</a></li>
			<li><a href="http://backbone.codeschool.com/levels/1/challenges/5">backbone.codeschool</a></li>
			<li><a href="https://github.com/k33g/articles/blob/master/2011-07-19-BACKBONE.md">MON 1ER TUTO BACKBONE.JS</a></li>
		</ul>
	</p>
</section>

<section><h2>English to French</h2>
<ul>
	<li>By default</li>
</ul>
</section>

